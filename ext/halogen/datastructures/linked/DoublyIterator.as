/** * Copyright (c) 2010 Henry Tseng (http://www.henrytseng.com) *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */package halogen.datastructures.linked {	import halogen.datastructures.IIterator;	/**	 * An iterator for <code>DoublyList</code>.  	 * @author henry	 */	public class DoublyIterator implements IIterator {		protected var _list : DoublyLinkedList;		protected var _next : DoublyNode;				/**		 * Constructor		 */		public function DoublyIterator($list:DoublyLinkedList) {			_list=$list;			_next = _list._head;		}				/**		 * Returns <code>true</code> if the iteration has more elements.		 * @return <code>true</code> if next node is available		 */		public function hasNext():Boolean {			return _next!=null;		}				/**		 * Move iterator to next item and retrieve data item.  Next item begins at list head at start.  		 * @return Returns the next data in the collection.  		 */		public function next():* {			var n:DoublyNode = _next;			forward();			return n._data;		}				/**		 * Move iterator to next item		 */		public function forward():void {			_next=_next._next;		}				/**		 * Move iterator to prev item		 */		public function reverse():void {			_next=_next._prev;		}				/**		 * Insert data after current node		 * @param $data data to insert		 */		public function insertAfter($data:*):void {			_next._insertAfter(new DoublyNode($data));		}				/**		 * Insert data before current node		 * @param $data data to insert		 */		public function insertBefore($data:*):void {			_next._insertBefore(new DoublyNode($data));		}				/**		 * Remove data after current node		 */		public function removeAfter():void {			_next._removeAfter();		}				/**		 * Remove data before current node		 */		public function removeBefore():void {			_next._removeBefore();		}				/**		 * Set data at current node.  		 * @param $data data to set		 */		public function set data($data:*):void {			_next._data=$data;		}				/**		 * Get data at current node.  		 * @return data on current node		 */		public function get data():* {			return _next._data;		}				/**		 * Removes the current node 		 */		public function remove():void {			var last:DoublyNode=null;			for(var n:DoublyNode=_list._head; n!=null; n=n._next) {				if(n==_next) {					if(last!=null) last._next = n._next;					if(_list._head==n) _list._head=n._next;					if(_list._tail==n) _list._tail=last;					return;				}				last=n;			}		}				public function toString():String { return '[DoublyIterator]'; }				/**		 * Destroy		 */		public function destroy():void {			_list=null;			_next=null;		}	}}